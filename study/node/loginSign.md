# OAuth2.0

OAuth出现的背景在于第三方登录，即在有第三方想要嵌入我们的内容的时候，又需要我们的用户验证，类似于微信的第三方登录而想出来的一套登录的验证规则

![流程图](../public/image/12.png)

这个图是我最近在研发叮咚的一个第三方接入平台时根据OAuth完成的一个联合登陆步骤

## 什么是OAuth2.0

先试想下最简单的登录步骤是需要什么内容

1. 账号密码
2. 与服务器交互获取登录token
3. 存到本地，下次登录的时候带上这个token

这是一个最简单的登录模式，如果仅仅是在自己系统中使用，虽然也存在一定的诟病，但是并没有什么不太对的地方

但是，在考虑一下之前说的那个场景，如果一个第三方的平台需要接入到我们的服务，上述的流程是否还能正常的走的通

### 远程信息验证

是的，正如上面所说，一个第三方应用想使用一个我们应用的服务，首先得需要能够使用服务的权限，而这个权限是靠用户登录来获取的，如果是按照之前的方法来实现的话会变成下面的这种场景

#### 两次登录

最粗俗，最粗暴的，最简单的做法就是将第三方应用与我们的应用进行权限隔离，他们登录他们的，但是想使用我们的服务之前，必须再登录一次我们的账户，这样就会存在以下几种问题

1. 两次登录的体验极差
2. 无法实现双方数据联通，第三方嵌入没有意义

#### 一次登录

基于上述的两次登录的极差体验，提出了只需要登录一次就能够联通双方用户信息，实现联合登录授权，这也就是OAuth出现的真正原因，那具体是如何实现这个方式的呢

1. 用户请求登录
2. 第三方发起登录，返回必要信息和重定向url
3. 我们将必要信息和重定向url发送到后端权限验证的服务器（权限验证的网关）
4. 直接重定向至url，返回一个临时code
5. 第三方带上临时code，AppID，AppSecret跟我们权限服务器换取access_token， refresh_access_token
6. 返回access_token, refresh_access_token给我们，我们存于本地，后续服务都带上这个access_token

#### 临时code

临时code的作用主要还是用于对换取access_token的接口的一种保护，一旦使用过用code就不能再次使用，并且在十分钟之内如果没有去调用的话，也会过期

#### 换取access_token

验证过code之后，会对id以及secret进行一个数据库查询，如果查询到对应数据那么就会针对secret的内容进行一个封装，生成一个access_token
