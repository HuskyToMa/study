## 遍历器（iterator）

在es6之前想要遍历只能通过js原生提供的方法进行数据遍历，对于一些不可迭代的属性进行遍历是比较麻烦的事情，例如object属性，他本身是不可迭代的，想要进行迭代只能先获取当且的keys属性，然后通过keys属性进行迭代

在es6里面添加一个新的迭代方法 `for...of` ，他通过使用iterator接口自定义的遍历的将要遍历的内容，在es6里，默认的iterator接口指的是`Symbol.iterator` ，也就是说当一个对象中存在 `Symbol.iterator` 的时候那么就认为这个对象是可遍历的

但是对于一些属性而言他们本身就存在iterator可迭代的属性，例如数组

``` javascript

const arr = [1, 2, 3];
const iter = arr[Symbol.iterator]();

iter.next() // {value: 1, done: false}
iter.next() // {value: 2, done: false}
iter.next() // {value: 3, done: false}
iter.next() // {value: underfined, done: true}
iter.next() // {value: underfined, done: true}

```

当next方法被调用超过了当前数组的长度的时候返回的就是undefined和done为true的内容

如果直接对object对象进行遍历的话，那么就会直接进行报错，因为对于object本身来说他是不可遍历的

![遍历](../public/image/6.png)

当然也是有办法将不可遍历的内容变成为可遍历的属性

```javascript

const obj = {
    '1': 1,
    '2': 2,
    '3': 3
}

obj.__proto__[Symbol.iterator] = function() {

    const keys = Object.keys(this);
    let currentIndex = 0;

    this.next = () => {
        if (currentIndex >= keys.length) {
            return { done: true }
        } else {
            return { value: obj[keys[currentIndex++]], done: false }
        }
    }

    return this;
}

for(let value of obj) {
    console.log(value)
}

// 1
// 2
// 3

```

为object对象添加了 `Symbol.iterator` 方法，并内部实现了next的迭代方案，这样就可以通过 `for...of`来进行遍历

当然我们也可以通过借用Array的迭代器接口去对obj进行改造

``` javascript

const obj = {
    0: 1,
    1: 2,
    2: 3,
    length: 3,
    [Symbol.iterator]: Array.prototype[Symbol.iterator]
}

for (let v of obj) {
    console.log(v);
}

// 1
// 2
// 3
```
