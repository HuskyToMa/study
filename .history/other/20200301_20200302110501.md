# 企业级脚手架搭建

起因我是一位阿里的大佬给了一段问题，说搭建一个企业级脚手架，虽然我之前也写过一些脚手架搭建的内容，但是没有一个完全的整合以及发布到npm的一个实操版本，只是给我自己的一些学习内容进行了记录，所以，当我看到这些问题的时候，我第一个反应是将我所学的内容进行一个整合并优化

## 脚手架架构图

![脚手架](../public/image/10.jpg)

这也是我的个人一个习惯，在开始写东西之前，一定要先想下，这个写的内容具体包含了什么然后针对性的去展开，虽然这也是要求之一，但是完全符合我个人的开发习惯

我将整个脚手架内容分成了4个部分，其实也可以算是3块主要的内容，因为argv_store是自己写的一个管理cli参数的一个库

- argv_store
- webpack配置
- 项目代码
- cli工具

## argv_store

[https://github.com/HuskyToMa/argv-store](https://github.com/HuskyToMa/argv-store)

他是一个管理我们在cli界面上输入的参数， 例如：

> mj-cli create --rename test

当使用`mj-cli`的时候使用的`argv_store`会获取到的你的参数以及对应的内容，即：

```javascript

// command参数就是create
// 获取到的options参数
{
    '--rename': 'test'
}

```

内容很简单，甚至说没有什么可以表达很优秀的地方，但是这就是我想要的一种效果

相比较社区的通用性方案`commander`，我写的这个库在复杂性上暂时还没法与其相比，但是我为什么不使用`commander`而是自己重新写了一个这样的处理工具，因为我想要将代码的可读性达到更高，能够一眼就识别出，你这个方案运行的方法是什么，让下一个人直接能够看出来

在这一层次，对比一下我们的实现方法：

```javascript

// commander
program
  .command('setup [env]')
  .description('run setup commands for all envs')
  .option("-s, --setup_mode [mode]", "Which setup mode to use")
  .action(callback);

program
  .command('exec <cmd>')
  .description('execute the given remote cmd')
  .option("-e, --exec_mode <mode>", "Which exec mode to use")
  .action(callback)

program.parse();

// argv_store
program
    .command('exec', 'execute the given remote cmd', callback)
    .option('-e, --exec', 'Which exec mode to use')
    .command('setup','run setup commands for all envs', callback)
    .option('-s, --set', 'Which setup mode to use')
    .parse()

// 当然这两种方式都是可以互通的不管是argv_store还是commander，都可以支持这两种写法
```

我承认我在一开始是准备使用`commander`的，但是当我看到这种使用方式以及方法的时候，我感觉我个人的灵魂不太想用（纯粹是个人原因），然后我就大部分借鉴`commander`的使用方式，自己编写了一个`argv_store`的库，从复杂度上讲，还比不上`commander`，但是从可读性上来说，我觉得我这个能够看得更加清晰明了

具体的`argv_store`的使用方法我就不详细阐述，在github上都有写，虽然也是很简单（狗头自保）

## webpack配置

其实我最开始入手写的应该是这块内容，但是我为什么我会将`argv_store`先讲呢，因为他其实是游离在脚手架之外的内容，并不属于脚手架，毕竟只是我个人的习惯而且做的一个改变

在开始写的时候，就一直在回忆，我之前学的内容具体有什么，有什么可以体现在这个配置上面的，然后根据我的区分大致上分为了以下几类：

- 基本配置
- 缓存处理
- 环境区分
- 打包优化
- 可外部配置
- script命令

### 基本配置

是的，基本配置，就是我们写webpack的时候必须要写的一些内容，以下会简单介绍下略有区别的内容

#### entry

针对入口文件，我思考了下，决定选择单页以及多页都可以运行的模式，这就需要与业务代码进行深层次的耦合

在入口文件获取的时候，首先会判断当然业务代码的`src`目录下是不是会有index.js文件，如果存在就会使用单页面的构建方式去进行构建，当找不到index.js文件的时候，会去找`src/view`下的每个文件夹里的`index.jsx`文件，将每个文件夹的名称作为html文件的name

```javascript

if (fs.existsSync(signalPath)) {
    entryObj.index = signalPath;
} else {
    const data = fs.readdirSync(viewPath);
    data.map(name => {
        const dirPath = `${viewPath}/${name}`;
        const stats = fs.statSync(dirPath);
        if (stats.isDirectory() && fs.existsSync(`${dirPath}/index.jsx`)) {
            entryObj[name] = `${dirPath}/index.jsx`;
        }
    })
}

Object.keys(entryObj).map(key => htmlPlugin.push(new htmlWebpackPlugin({
    template: `${DIR}/template/index.tpl.ejs`,
    filename: `${key}.html`,
    minify: true,
    inject: true,
    collapseWhitespace: true
})));

```

#### optimization

在选择压缩的时候，会考虑到开发环境以及生产环境，所以在开发环境的时候就不进行压缩，在生产环境中才会去压缩js跟css

#### module

module里除了正常的针对js，css，img，front等内容进行编译以外，针对less/sass，这边特意做了一些支持，一个项目里面同时支持module以及非module形式的内容，使用oneof来只使用其中一个内容


