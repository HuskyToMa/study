# 企业级脚手架搭建

起因我是一位阿里的大佬给了一段问题，说搭建一个企业级脚手架，虽然我之前也写过一些脚手架搭建的内容，但是没有一个完全的整合以及发布到npm的一个实操版本，只是给我自己的一些学习内容进行了记录，所以，当我看到这些问题的时候，我第一个反应是将我所学的内容进行一个整合并优化

## 脚手架架构图

![脚手架](../public/image/10.png)

这也是我的个人一个习惯，在开始写东西之前，一定要先想下，这个写的内容具体包含了什么然后针对性的去展开，虽然这也是要求之一，但是完全符合我个人的开发习惯

我将整个脚手架内容分成了4个部分，其实也可以算是3块主要的内容，因为argv_store是自己写的一个管理cli参数的一个库

- argv_store
- 项目代码
- cli工具
- webpack配置

## argv_store

[https://github.com/HuskyToMa/argv-store](https://github.com/HuskyToMa/argv-store)

他是一个管理我们在cli界面上输入的参数， 例如：

> mj-cli create --rename test

当使用`mj-cli`的时候使用的`argv_store`会获取到的你的参数以及对应的内容，即：

```javascript

// command参数就是create
// 获取到的options参数
{
    '--rename': 'test'
}

```

内容很简单，甚至说没有什么可以表达很优秀的地方，但是这就是我想要的一种效果

相比较社区的通用性方案`commander`，我写的这个库在复杂性上暂时还没法与其相比，但是我为什么不使用`commander`而是自己重新写了一个这样的处理工具，因为我想要将代码的可读性达到更高，能够一眼就识别出，你这个方案运行的方法是什么，让下一个人直接能够看出来

在这一层次，对比一下我们的实现方法：

```javascript

// commander

program
  .command('setup [env]')
  .description('run setup commands for all envs')
  .option("-s, --setup_mode [mode]", "Which setup mode to use")
  .action(callback);

program
  .command('exec <cmd>')
  .description('execute the given remote cmd')
  .option("-e, --exec_mode <mode>", "Which exec mode to use")
  .action(callback)

program.parse();
// argv_store

program
    .command('exec', 'execute the given remote cmd', callback)
    .option('-e, --exec')
    .command('setup','run setup commands for all envs', callback)
    .option('-s, --set')
    .parse()


```

我承认我在一开始是准备使用`commander`的，但是当我看到这种使用方式以及方法的时候，我感觉我个人的灵魂不太想用（纯粹是个人原因），然后我就大部分借鉴`commander`的使用方式，自己编写了一个`argv_store`的库，从复杂度上讲，还比不上`commander`，但是从可读性上来说，我觉得我这个能够看得更加清晰明了

