## webpack的脚手架搭建

### entry

1. 将公用的文件打包成一个独立的模块

    ``` javascript
        entry: {
        vendor: ['antd'],
        react: ['react', 'react-router', 'react-redux', 'redux', 'redux-saga'],
        index: path.resolve(__dirname, '../src/index.ts')
    },
    ```

2. 单入口的只需要写一个文件入口，多入口的需要添加多个文件入口以及 多个 htmlWebpackPlugin
3. resolve设置extensions的时候，需要添加'.js'而不是'js'
4. 将公用的lessLoader分离出去，dev环境不需要打包出额外的css，pro环境需要从js中读取css组成文件（mini-css-extract-plugin）
5. 将图片等文件用url-loader处理，超过4KB就用路径，小于4KB则用base64
6. 开发使用hotonly而不是用hot，避免每次修改重新刷新页面
7. 添加const文件，获取当前目录文件路径
8. pro环境添加js代码压缩（uglifyjs-webpack-plugin）
9. pro环境添加css文件压缩插件（optimize-css-assets-webpack-plugin）

### 自动化测试

https://travis-ci.org/

### 性能优化

1. 使用happypack进行多进行/多实例打包

```javascript

    module: {
        rules: [
            {
                test: /.(ts|tsx)$/,
                loader: 'HappyPack/loader?id=babelLoader',
                exclude: /node_modules/
            }
        ]
    }

    plugins: [
        new HappyPack({
            id: 'babelLoader',
            cache: true,
            loaders: ['babel-loader']
        })
    ]

```

2. 使用dll预编译模式对公共包进行打包

``` javascript

    // webpack.dll.conf.js
    module.exports = {
        entry: {
            react: ['react', 'react-dom'],
            redux: ['redux', 'react-redux', 'redux-saga'],
            reactRouter: ['react-router', 'react-router-dom']
        },
        output: {
            path: path.resolve(__dirname, "./dll"),
            filename: "myDll.[name].js",
            library: "[name]_[fullhash]"
        },
        plugins: [
            new webpack.DllPlugin({
                path: path.resolve(__dirname, "./dll", "[name]-manifest.json"),
                name: "[name]_[fullhash]"
            })
        ]
    }

    // webepack.pro.conf.js
    new webpack.DllReferencePlugin({
        manifest: require('./dll/react-manifest.json'),
        name: './myDll-react.js',
    })
```

3. tree Shaking 擦除无用的css代码

``` javascript

    const glob = require('glob');

    const PATHS = {
        src: path.join(__dirname, 'src')
    }

    new PurgecssPlugin({
        paths: glob.sync(`${PATHS.src}/**/*`,  { nodir: true }),
    }),

```

4. 使用cache进行构建缓存
5. 对图片进行压缩
    - Node库 imagemin / yinypng API
    - image-webpack-loader
6. 动态polyfill
    - polyfill Service 识别User Agent，动态下发不同的plyfill
    - polyfill.is/v3/polyfill.min.js


### 源码分析

入口文件：
    1. process.exitCode   正常执行返回
    2. runCommand   运行命令
    3. isInstalled  判断是否存在包（require.resolve）
    4. CLIs         webpack可用包，webpack-cli，webpack-command
    5. isInstalledCLIs  判断是否安装命令行包
    6. webpack会去寻找webpack-cli执行其命令
    7. webpack-cli使用yargs配置命令行参数
    8. webpack-cli最终使用webepack构建

tapable：

> 类似于nodejs的eventEmitter的库（发布订阅），控制webpack的插件系统

```javascript

const {
    SyncHook,
    SyncBailHook,
    SyncWaterfallHook,
    SyncLoopHook,
    AsyncParallelHook,
    AsyncParallelBailHook,
    AsyncSeriesHook,
    AsyncSeriesBailHook,
    AsyncSeriesWaterfallHook,
    MultiHook,
    HookMap,
    Tapable
} = require('tapable')

```
> tapable中的钩子名称对应含义

type | function
:-- | :--
Hook | 所有钩子的后缀
Waterfall | 同步方法，会传值给下一个函数
Bail | 熔断：当函数有返回值的时候，就会在当前执行函数停止
Loop | 监听函数返回truee表示继续循环，返回undefined表示结束循环
Sync | 同步方法
AsyncSeries | 异步串行钩子
AsyncParallel | 异步并行执行钩子